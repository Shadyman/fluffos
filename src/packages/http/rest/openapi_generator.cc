#include "rest_router.h"
#include "../http_parser.h"

/*
 * OpenAPI Generator - OpenAPI 3.0 Specification Generation
 * 
 * Generates OpenAPI 3.0 specifications from REST routes and API information.
 * Provides documentation generation capabilities for REST APIs.
 * Moved from original rest_handler.cc as part of architecture correction.
 */

#include <sstream>
#include <iomanip>

class OpenAPIGenerator {
private:
    std::string api_title_;
    std::string api_version_;
    std::string api_description_;
    std::string base_path_;
    std::vector<std::string> servers_;
    
public:
    OpenAPIGenerator() 
        : api_title_("FluffOS REST API")
        , api_version_("1.0.0")
        , api_description_("RESTful API generated by FluffOS HTTP package")
        , base_path_("/api") {
        servers_.push_back("http://localhost");
    }
    
    std::string generate_openapi_spec(const std::vector<std::unique_ptr<RestRoute>>& routes) {
        std::ostringstream spec;
        
        // OpenAPI 3.0 header
        spec << "{\n";
        spec << "  \"openapi\": \"3.0.0\",\n";
        spec << "  \"info\": {\n";
        spec << "    \"title\": \"" << escape_json_string(api_title_) << "\",\n";
        spec << "    \"version\": \"" << escape_json_string(api_version_) << "\",\n";
        spec << "    \"description\": \"" << escape_json_string(api_description_) << "\"\n";
        spec << "  },\n";
        
        // Servers
        spec << "  \"servers\": [\n";
        for (size_t i = 0; i < servers_.size(); ++i) {
            spec << "    { \"url\": \"" << escape_json_string(servers_[i]) << "\" }";
            if (i < servers_.size() - 1) spec << ",";
            spec << "\n";
        }
        spec << "  ],\n";
        
        // Paths
        spec << "  \"paths\": {\n";
        generate_paths_section(spec, routes);
        spec << "  },\n";
        
        // Components (schemas, security, etc.)
        spec << "  \"components\": {\n";
        spec << "    \"schemas\": {\n";
        generate_common_schemas(spec);
        spec << "    },\n";
        spec << "    \"securitySchemes\": {\n";
        generate_security_schemes(spec);
        spec << "    }\n";
        spec << "  }\n";
        
        spec << "}\n";
        
        return spec.str();
    }
    
    std::string generate_api_docs_html(const std::vector<std::unique_ptr<RestRoute>>& routes) {
        std::ostringstream html;
        
        html << "<!DOCTYPE html>\n";
        html << "<html>\n";
        html << "<head>\n";
        html << "  <title>" << api_title_ << " - API Documentation</title>\n";
        html << "  <style>\n";
        html << "    body { font-family: Arial, sans-serif; margin: 40px; }\n";
        html << "    h1, h2, h3 { color: #333; }\n";
        html << "    .route { border: 1px solid #ddd; margin: 20px 0; padding: 15px; }\n";
        html << "    .method { font-weight: bold; color: white; padding: 5px 10px; border-radius: 3px; }\n";
        html << "    .get { background-color: #61affe; }\n";
        html << "    .post { background-color: #49cc90; }\n";
        html << "    .put { background-color: #fca130; }\n";
        html << "    .delete { background-color: #f93e3e; }\n";
        html << "  </style>\n";
        html << "</head>\n";
        html << "<body>\n";
        
        html << "<h1>" << api_title_ << "</h1>\n";
        html << "<p>" << api_description_ << "</p>\n";
        html << "<p><strong>Version:</strong> " << api_version_ << "</p>\n";
        
        html << "<h2>API Endpoints</h2>\n";
        
        for (const auto& route : routes) {
            html << "<div class=\"route\">\n";
            html << "  <h3>\n";
            html << "    <span class=\"method " << to_lower(route->method) << "\">" 
                 << route->method << "</span> ";
            html << route->pattern << "\n";
            html << "  </h3>\n";
            
            if (!route->description.empty()) {
                html << "  <p>" << route->description << "</p>\n";
            }
            
            if (!route->param_names.empty()) {
                html << "  <h4>Parameters:</h4>\n";
                html << "  <ul>\n";
                for (const auto& param : route->param_names) {
                    html << "    <li><code>" << param << "</code> - Path parameter</li>\n";
                }
                html << "  </ul>\n";
            }
            
            html << "  <p><strong>Handler:</strong> " << route->handler_object 
                 << "::" << route->handler_function << "</p>\n";
            
            if (route->requires_auth) {
                html << "  <p><strong>Authentication:</strong> Required</p>\n";
            }
            
            html << "</div>\n";
        }
        
        html << "</body>\n";
        html << "</html>\n";
        
        return html.str();
    }
    
    void set_api_info(const std::string& title, const std::string& version, 
                     const std::string& description) {
        api_title_ = title;
        api_version_ = version;
        api_description_ = description;
    }
    
    void add_server(const std::string& url) {
        servers_.push_back(url);
    }
    
    void set_base_path(const std::string& base_path) {
        base_path_ = base_path;
    }
    
private:
    void generate_paths_section(std::ostringstream& spec, 
                               const std::vector<std::unique_ptr<RestRoute>>& routes) {
        // Group routes by path
        std::unordered_map<std::string, std::vector<const RestRoute*>> path_routes;
        for (const auto& route : routes) {
            path_routes[route->pattern].push_back(route.get());
        }
        
        bool first_path = true;
        for (const auto& path_group : path_routes) {
            if (!first_path) spec << ",\n";
            first_path = false;
            
            spec << "    \"" << escape_json_string(path_group.first) << "\": {\n";
            
            bool first_method = true;
            for (const RestRoute* route : path_group.second) {
                if (!first_method) spec << ",\n";
                first_method = false;
                
                spec << "      \"" << to_lower(route->method) << "\": {\n";
                spec << "        \"summary\": \"" << escape_json_string(route->description) << "\",\n";
                spec << "        \"operationId\": \"" << route->handler_function << "\",\n";
                
                // Parameters
                if (!route->param_names.empty()) {
                    spec << "        \"parameters\": [\n";
                    for (size_t i = 0; i < route->param_names.size(); ++i) {
                        spec << "          {\n";
                        spec << "            \"name\": \"" << route->param_names[i] << "\",\n";
                        spec << "            \"in\": \"path\",\n";
                        spec << "            \"required\": true,\n";
                        spec << "            \"schema\": { \"type\": \"string\" }\n";
                        spec << "          }";
                        if (i < route->param_names.size() - 1) spec << ",";
                        spec << "\n";
                    }
                    spec << "        ],\n";
                }
                
                // Responses
                spec << "        \"responses\": {\n";
                spec << "          \"200\": {\n";
                spec << "            \"description\": \"Successful response\",\n";
                spec << "            \"content\": {\n";
                spec << "              \"application/json\": {\n";
                spec << "                \"schema\": { \"type\": \"object\" }\n";
                spec << "              }\n";
                spec << "            }\n";
                spec << "          }\n";
                spec << "        }\n";
                
                spec << "      }";
            }
            spec << "\n    }";
        }
        spec << "\n";
    }
    
    void generate_common_schemas(std::ostringstream& spec) {
        spec << "      \"Error\": {\n";
        spec << "        \"type\": \"object\",\n";
        spec << "        \"properties\": {\n";
        spec << "          \"error\": { \"type\": \"string\" },\n";
        spec << "          \"message\": { \"type\": \"string\" }\n";
        spec << "        }\n";
        spec << "      }\n";
    }
    
    void generate_security_schemes(std::ostringstream& spec) {
        spec << "      \"bearerAuth\": {\n";
        spec << "        \"type\": \"http\",\n";
        spec << "        \"scheme\": \"bearer\",\n";
        spec << "        \"bearerFormat\": \"JWT\"\n";
        spec << "      },\n";
        spec << "      \"apiKey\": {\n";
        spec << "        \"type\": \"apiKey\",\n";
        spec << "        \"in\": \"header\",\n";
        spec << "        \"name\": \"X-API-Key\"\n";
        spec << "      }\n";
    }
    
    std::string escape_json_string(const std::string& input) {
        std::string escaped;
        for (char c : input) {
            switch (c) {
                case '"': escaped += "\\\""; break;
                case '\\': escaped += "\\\\"; break;
                case '\n': escaped += "\\n"; break;
                case '\r': escaped += "\\r"; break;
                case '\t': escaped += "\\t"; break;
                default: escaped += c; break;
            }
        }
        return escaped;
    }
    
    std::string to_lower(const std::string& input) {
        std::string result = input;
        std::transform(result.begin(), result.end(), result.begin(), ::tolower);
        return result;
    }
};

// Global OpenAPI generator instance
static OpenAPIGenerator global_openapi_generator;